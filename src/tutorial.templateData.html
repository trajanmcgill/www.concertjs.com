<template:targetDef target="tutorial01.html" template="ConcertJSPage.template.html"></template:targetDef>
<template:targetDef target="tutorial02.html" template="ConcertJSPage.template.html"></template:targetDef>
<template:targetDef target="tutorial03.html" template="ConcertJSPage.template.html"></template:targetDef>
<template:targetDef target="tutorial04.html" template="ConcertJSPage.template.html"></template:targetDef>
<template:targetDef target="tutorial05.html" template="ConcertJSPage.template.html"></template:targetDef>
<template:targetDef target="tutorial06.html" template="ConcertJSPage.template.html"></template:targetDef>
<template:targetDef target="tutorial07.html" template="ConcertJSPage.template.html"></template:targetDef>
<template:targetDef target="tutorial08.html" template="ConcertJSPage.template.html"></template:targetDef>
<template:targetDef target="tutorial09.html" template="ConcertJSPage.template.html"></template:targetDef>

<template:data target="tutorial01.html" section="HeadContent">
<template:data target="tutorial02.html" section="HeadContent">
<template:data target="tutorial03.html" section="HeadContent">
<template:data target="tutorial04.html" section="HeadContent">
<template:data target="tutorial05.html" section="HeadContent">
<template:data target="tutorial06.html" section="HeadContent">
<template:data target="tutorial07.html" section="HeadContent">
<template:data target="tutorial08.html" section="HeadContent">
<template:data target="tutorial09.html" section="HeadContent">
	<link rel="stylesheet" type="text/css" href="Styles/tutorial.css" />

	<script type="text/javascript" src="Scripts/tutorial.js"></script>
</template:data>
</template:data>
</template:data>
</template:data>
</template:data>
</template:data>
</template:data>
</template:data>
</template:data>

<template:data target="tutorial01.html" section="DescriptionAreaContent">
<template:data target="tutorial02.html" section="DescriptionAreaContent">
<template:data target="tutorial03.html" section="DescriptionAreaContent">
<template:data target="tutorial04.html" section="DescriptionAreaContent">
<template:data target="tutorial05.html" section="DescriptionAreaContent">
<template:data target="tutorial06.html" section="DescriptionAreaContent">
<template:data target="tutorial07.html" section="DescriptionAreaContent">
<template:data target="tutorial08.html" section="DescriptionAreaContent">
<template:data target="tutorial09.html" section="DescriptionAreaContent">
	<h3>Getting Started With Concert.js</h3>
	<div>
		The below series of examples teaches the concepts and usage of Concert.js
		through working sample code with explanations, starting with the most
		basic concepts and progressing up to demonstrate some advanced uses.

		See the <a href="Reference/index.html">reference documentation</a> for all the details
		of everything mentioned here and more.
	</div>
</template:data>
</template:data>
</template:data>
</template:data>
</template:data>
</template:data>
</template:data>
</template:data>
</template:data>

<!-- ================================================================= -->
<!-- TUTORIAL 01: Sequences and Transformations -->
<template:data target="tutorial01.html" section="MainContent">
	<div>
		<div class="TutorialNavigation">
			<ol>
				<li><strong>Sequences and Transformations</strong></li>
				<li><a href="tutorial02.html">Easing Functions</a></li>
				<li><a href="tutorial03.html">Calculators</a></li>
				<li><a href="tutorial04.html">Applicators</a></li>
				<li><a href="tutorial05.html">Setting Defaults</a></li>
				<li><a href="tutorial06.html">Starting, Stopping, Seeking, and Synchronizing</a></li>
				<li><a href="tutorial07.html">Repeating</a></li>
				<li><a href="tutorial08.html">Cloning and Retargeting</a></li>
				<li><a href="tutorial09.html">Indexing, Value Generator Functions</a></li>
				</ol>
		</div>
		<div class="TutorialIntroSection">
			<h2>Sequences and Transformations</h2>
			<p>
				The most basic conceptual pieces involved in using Concert.js are the <code>Sequence</code> and the <code>Transformation</code>.
			</p>
			<p>
				A <code>Transformation</code> is a single change applied over time to a single feature of a single object.
				For instance, it could be a change in the height of a DOM element from 0px to 24px over 1000ms (1 second).
			</p>
			<p>
				A <code>Sequence</code> is a whole series of changes applied to a collection of objects over time. It contains one or more transformations.
			</p>
			<p>
				Anything we do with Concert.js will involve creating and working with a <code>Sequence</code> object.
			</p>
		</div>

		<div class="TutorialStep"> <!-- Page 01 Example 01: What does a simple Concert.js animation look like? -->
			<h4>What does a simple Concert.js animation look like?</h4>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame" src="TutorialExamples/Page01Example01.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page01Example01.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				<pre><code>let sequence = new Concert.Sequence();

sequence.addTransformations(
  {
    target: document.getElementById("HelloDiv"),
    feature: "height",
    unit: "px",
    applicator: Concert.Applicators.Style,
    keyframes: { times: [0, 2000], values: [0, 24] }
  });

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
</code></pre>
			</p>
			<p>
				The above code does the following:
				<ul class="TutorialBullets">
					<li>Creates a single new <code>Concert.Sequence</code> object.</li>
					<li>Passes an object defining a single animated transformation into the sequence's <code>addTransformations()</code> method.</li>
					<li>
						Upon clicking the "Go" button, calls the sequence's <code>begin()</code> method to run the animated sequence.
						We'll see later that there are several ways to run an animation or synchronize it to something else happening on the page,
						but <code>begin()</code> is the simplest-- it just runs the sequence from beginning to end, synchronized to the system clock.
					</li>
				</ul>
			</p>
			<p>
				Let's look at each of the properties of the object that defines a single animated feature (a <code>Transformation</code>).
				Later we'll see that it is not always necessary to specify every one of these properties, because we can set default values for them.
				<ul class="TutorialBullets">
					<li><em>target</em>: The object that will be modified by the animation. In this case, it is a <code>div</code> with <code>id</code> "HelloDiv" which we want to slowly reveal.</li>
					<li><em>feature</em>: Which property of the target object will be modified. In this case, it is the <code>height</code> property (of the above-mentioned <code>div</code> object).</li>
					<li><em>unit</em>: What unit is being applied with the property's numeric value when. Here it is "px", but it could be anything else applicable, such as "em", "%", or even <code>null</code> for animating things which don't require an appended unit string.</code></li>
					<li>
						<em>applicator</em>:
						A function that tells the sequence how to apply the animation values.
						In this case, what is being modified is the target object's style,
						so we use a pre-defined applicator function for modifying CSS styles.
						More details on what this means and how this works in a later tutorial step.
					</li>
					<li>
						<em>keyframes</em>:
						An object containing two arrays: <code>times</code>, which is a list of moments in a timeline (here measured in milliseconds),
						and <code>values</code>, a corresponding list of values to apply at those times. Intermediate values will be calculated
						automatically between those keyframes.
					</li>
				</ul>
				So in summary, what the above code says is to take the <code>div</code> with <code>id</code> "HelloDiv", and modify its height style,
				setting it to 0px at time 0, and smoothly animating it until it reaches 24px at time 2000 (that is, at 2 seconds).
				If you click the "Go" button, you'll see it work.
			</p>
		</div>

		<div class="TutorialStep"> <!-- Page 01 Example 02: How about a sequence with more than one transformation? -->

			<h4>How about a sequence with more than one transformation?</h4>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame" src="TutorialExamples/Page01Example02.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page01Example02.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				<pre><code>let sequence = new Concert.Sequence(),
  box1 = document.getElementById("Box1");
				
let box1Transformations = 
  [
    {
      target: box1,
      feature: "left",
      unit: "px",
      applicator: Concert.Applicators.Style,
	  keyframes: { times: [0, 1000], values: [0, 265] }
    },
	
    {
      target: box1,
      feature: "top",
      unit: "px",
      applicator: Concert.Applicators.Style,
	  keyframes: { times: [0, 1000], values: [0, 65] }
    }
  ];

sequence.addTransformations(box1Transformations);

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
</code></pre>
			</p>
			<p>
				As can be seen above, <code>addTransformations()</code> can take an entire array of transformation objects.
				Here we transform two different features (the top and left style properties of the target object),
				each one having its own independent movement.
				Note that the same could have been accomplished by calling <code>addTransformations()</code> once with each transformation object.
			</p>
			<p>
				<strong>Shortcut:</strong>
				Multiple target features can be specified together in an array. This requires passing arrays of values as well.
				For instance, the below code would work exactly the same as the above, but is much more concise.
				Note that the value at time zero (as well as at time 1000) is an array.
				The first value is paired with the first feature ("left"), and the second value is paired with the second feature ("top").
			</p>
			<p><pre><code>let sequence = new Concert.Sequence(),
  box1 = document.getElementById("Box1");
				
let box1Transformations = 
  {
    target: box1,
    feature: ["left", "top"],
    unit: "px",
    applicator: Concert.Applicators.Style,
    keyframes: { times: [0, 1000], values: [[0, 0], [265, 65]] }
  };

sequence.addTransformations(box1Transformations);

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
</code></pre></p>
		</div>

		<div class="TutorialStep"> <!-- Page 01 Example 03: What about gaps in motion? -->
			<h4>What about gaps in motion?</h4>
			<p>
				Normally, values are interpolated in between keyframes.
				If the goal instead is to have one animation segment, then a period of time with no animation, then another animation segment,
				that is possible as well. Watch how the two boxes behave differently:
			</p>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame" src="TutorialExamples/Page01Example03.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page01Example03.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				<pre><code>let sequence = new Concert.Sequence(),
  box1 = document.getElementById("Box1"),
  box2 = document.getElementById("Box2");

let boxTransformations = 
  [
    {
      target: box1,
      feature: "left",
      unit: "px",
      applicator: Concert.Applicators.Style,
      keyframes: { times: [0, 750, 1500, 2250], values: [0, 90, 180, 270] }
    },

    {
      target: box2,
      feature: "left",
      unit: "px",
      applicator: Concert.Applicators.Style,
      keyframes: { times: [0, 750, null, 1500, 2250], values: [0, 90, null, 180, 270] }
    }
  ];

sequence.addTransformations(boxTransformations);

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
</code></pre>
			</p>
			<p>
				Inserting a null in between keyframes has the effect of breaking the animation into separate segments.
				In the example above, the first box has continuous value interpolation between every keyframe and the one after it.
				The second box is animated continuously from time 0 to time 750, but then no new values are calculated and applied
				until hitting time 1500, at which point another animation segment begins.
				Do note that the <code>times</code> and <code>values</code> arrays do need to be the same length,
				and any nulls in one need to match nulls in the other.
			</p>
			<p>
				If you want a lot of discontinous segments, however, you may wish to look at an alternate method of describing transformations:
			</p>
		</div>

		<div class="TutorialStep"> <!-- Page 01 Example 04: Specifying Segments Rather Than Keyframes -->
			<h4>Specifying Segments Rather Than Keyframes</h4>
			<p>
				For some purposes, it is more useful to think of animations as a series of segments,
				rather than as a continuous series of keyframes and corresponding values.
			</p>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame" src="TutorialExamples/Page01Example04.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page01Example04.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				<pre><code>let sequence = new Concert.Sequence(),
  box1 = document.getElementById("Box1");
	
let boxTransformations = 
  [
    {
      target: box1,
      feature: "left",
      unit: "px",
      applicator: Concert.Applicators.Style,
      segments:
        [
          { t0: 0, t1: 1000, v0: 0, v1: 270 },
          { t0: 3000, t1: 4000, v0: 270, v1: 0 }
        ]
    },

    {
      target: box1,
      feature: "top",
      unit: "px",
      applicator: Concert.Applicators.Style,
      keyframes: { times: [1000, 2000, 3000], values: [0, 70, 0] }
    }
  ];

sequence.addTransformations(boxTransformations);

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
</code></pre>
			</p>
			<p>
				The first object in the <code>boxTransformations</code> array above uses a new notation.
				Instead of using <code>keyframes</code>, it specifies <code>segments</code>.
				Each segment object in the array represents one single start and end point of animation.
				It contains two properties corresponding to start and end times, <code>t0</code> and <code>t1</code>, respectively;
				and it contains two properties corresponding to start and end values, <code>v0</code> and <code>v1</code>, respectively.
				As demonstrated above, it is perfectly fine to mix segment notation and keyframe notation in the same sequence.
			</p>
			<p>
				One handy feature of segment notation is that various additional properties can be specified at the segment level,
				allowing each segment to have different characteristics, such as using different easing functions.
				(Easing functions are covered in the next step of this tutorial.)
			</p>
			<p>
				Whether you use keyframe or segment notation makes no difference in how the animation runs.
				Choosing one or the other is mainly a function of which one is easier for the task at hand.
				This choice can be especially useful when programmatically generating animations, where objects and arrays are being assembled by code,
				and one of these notations may fit better than the other for any given application.
			</p>
			<p>
				Note: Whether using keyframe or segment notation, do not try to add overlapping segments applying to the same object feature.
				For instance, consider an animation in which you've added a segment causing an element's "left" property to increase
				from 0 to 100 between time 0 and time 1000. Adding a second segment (whether by keyframe or segment notation) that differently
				adjusts the same element's "left" property between, say, time 500 and time 1500 does not make sense and results in undefined behavior.
			</p>
		</div>

		<p class="PreviousTutorialLink">
		</p>
		<p class="NextTutorialLink">
			<a href="tutorial02.html">Next: 02 - Easing Functions</a>
		</p>
	</div>
</template:data>


<!-- ================================================================= -->
<!-- TUTORIAL 02: Easing Functions -->
<template:data target="tutorial02.html" section="MainContent">
	<div>
		<div class="TutorialNavigation">
			<ol>
				<li><a href="tutorial01.html">Sequences and Transformations</a></li>
				<li><strong>Easing Functions</strong></li>
				<li><a href="tutorial03.html">Calculators</a></li>
				<li><a href="tutorial04.html">Applicators</a></li>
				<li><a href="tutorial05.html">Setting Defaults</a></li>
				<li><a href="tutorial06.html">Starting, Stopping, Seeking, and Synchronizing</a></li>
				<li><a href="tutorial07.html">Repeating</a></li>
				<li><a href="tutorial08.html">Cloning and Retargeting</a></li>
				<li><a href="tutorial09.html">Indexing, Value Generator Functions</a></li>
				</ol>
		</div>
		<div class="TutorialIntroSection">
			<h2>Easing Functions</h2>
			<p>
				Nice-looking, realistic motion requires more than just abrupt starts and stops
				with constant-rate motion in between. This is where easing functions come into play.
			</p>
			<p>
				An easing function causes the animation to proceed at a varying rate over time.
				For instance, it may start quickly, and then gradually come to a stop.
			</p>
			<p>
				Concert.js has five built-in easing functions, covering much of the sort of motion commonly seen in animations.
				It also easily allows you to supply your own, custom easing functions as well.
			</p>
		</div>

		<div class="TutorialStep"> <!-- What do the built-in easing functions look like, and how do I use them? -->
			<h4>What do the built-in easing functions look like, and how do I use them?</h4>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame" src="TutorialExamples/Page02Example01.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page02Example01.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				<pre><code>const LeftPosition = 0, RightPosition = 360, EndTime = 1500;

let animations =
  [
    {
      target: document.getElementById("Block_ConstantRate"),
      feature: "left",
      unit: "px",
      applicator: Concert.Applicators.Style,
      easing: Concert.EasingFunctions.ConstantRate,
      keyframes: { times: [0, EndTime], values: [LeftPosition, RightPosition] }
    },

    {
      target: document.getElementById("Block_QuadIn"),
      feature: "left",
      unit: "px",
      applicator: Concert.Applicators.Style,
      easing: Concert.EasingFunctions.QuadIn,
      keyframes: { times: [0, EndTime], values: [LeftPosition, RightPosition] }
    },

    {
      target: document.getElementById("Block_QuadInOut"),
      feature: "left",
      unit: "px",
      applicator: Concert.Applicators.Style,
      easing: Concert.EasingFunctions.QuadInOut,
      keyframes: { times: [0, EndTime], values: [LeftPosition, RightPosition] }
    },

    {
      target: document.getElementById("Block_QuadOut"),
      feature: "left",
      unit: "px",
      applicator: Concert.Applicators.Style,
      easing: Concert.EasingFunctions.QuadOut,
      keyframes: { times: [0, EndTime], values: [LeftPosition, RightPosition] }
    },

    {
      target: document.getElementById("Block_Smoothstep"),
      feature: "left",
      unit: "px",
      applicator: Concert.Applicators.Style,
      easing: Concert.EasingFunctions.Smoothstep,
      keyframes: { times: [0, EndTime], values: [LeftPosition, RightPosition] }
    }
  ];

let sequence = new Concert.Sequence();
sequence.addTransformations(animations);

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
</code></pre>
			</p>
			<p>
				The above code creates five nearly identical transformation set objects,
				each applying to a different <code>div</code> element.
				Each one specifies animating the element's CSS <code>left</code> style
				from 0 to 360px over a period of 1500 ms.
				The difference in each is the value specified for the <code>easing</code> property.
				These pre-defined easing functions allow for a smooth start and/or end to an animation.
			</p>
			<p>
				(If this looks like a lot of code for just a little bit of action, don't worry.
				Later in the tutorial we'll cover setting default values so that not every
				common property of every transformation set object needs to be repeated again and again.)
			</p>
		</div>

		<div class="TutorialStep"> <!-- Custom Easing Functions -->
			<h4>Custom Easing Functions</h4>
			<p>
				Sometimes it is necessary to use an easing function other than those already defined.
				Let's examine how that can be accomplished.
			</p>
			<p>
				First, let's look at what an easing function does, and what one looks like.
				An easing is a function which modifies the rate at which a transformation moves from beginning to end.
				For instance, it may progress steadily from the start time to the end time, or it may accelerate
				and decelerate to make motion appear smoother.
			</p>
			<p>
				Important to note is that an easing function does not change the total time of the animation at all.
				The start and end times remain the same; what changes is the rate of the motion in between those times.
			</p>
			<p>
				Besides the pre-defined easing functions we just saw above, Concert.js can also use a custom easing function.
				An easing function is any function which takes the form <code>function easingFunction(startTime, endTime, currentTime)</code>
				and returns a value from 0 to 1. <em>(At least, ordinarily. There do exist easing functions which involve travel beyond
				the start and end points, such as a slight out-of-bounds bounce-type movement, but most times you'll want to ensure
				your easing functions never go below 0 or above 1 to avoid unexpected behavior.)</em>
			</p>
			<p>
				The inputs represent the start time of the transition, the end time, and the current position
				along that timeline.
				<em>
					(Strictly speaking, these don't need to be times; if you were synchronizing your animation to, say,
					the position of a scroll bar rather than the system clock, the beginning and end would not be measured in microseconds.
					But in any case, there are a start point and an end point and a current place along that "timeline".)
				</em>
			</p>
			<p>
				The return value is a fraction representing the portion of the total distance the animation should have traversed
				in the time passed so far. This fraction is used to interpolate the current position in an animation segement.
			</p>
			<p>
				For instance, for a simple, constant rate of motion, you would want a function that just calculated the fraction of the timeline
				traveled, and returned the same fraction. That is, if start time is 0, end time is 100, and current time is 50,
				then 50% of the time has passed and therefore 50% of the animated transition should have occurred,
				so the value returned would be 0.5. And indeed, here is the code for the build-in ConstantRate easing function:
			</p>
			<p>
				<pre><code>ConstantRate:
  function (startTime, endTime, currentTime)
  {
    if (currentTime >= endTime)
      return 1;
    else if (currentTime < startTime)
      return 0;
    else
      return ((currentTime - startTime) / (endTime - startTime));
  }
</code></pre>
			</p>
			<p>
				All it does is return 1 (the full distance has been reached) if the end time is reached or passed, return 0 if the current time is at or before the start time,
				and for any current time value in between start time and end time, return the fraction of the total time that has so far gone by.
				This will result in animated motion that starts abruptly at the start time, moves at exactly the same rate as time progresses,
				and ends abruptly at the end time.
			</p>
			<p>
				Feel free to examine the Concert.js code to see how the other build-in easing functions are defined.
				They are all reasonably simple functions.
			</p>
			<p>
				But what if none of them meets your needs? Simply build your own, and as long as it has the right function signature
				and returns a fractional value indicating how far the animation should be considered to have progressed,
				you can pass that function in wherever you would use a built-in easing function.
				Here is an example:
			</p>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame" src="TutorialExamples/Page02Example02.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page02Example02.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				The above demonstrates an easing function which creates motion that accelerates to full speed and then decelerates to a pause
				three times over the course of its travel from beginning to end. Below is the code which accomplishes this.
			</p>
			<p>
				<pre><code>function triplePiston(startTime, endTime, currentTime)
{
  const Segments = 3,
    s = (endTime - startTime) / Segments,
    t = currentTime - startTime,
    distanceFraction =
      (Math.floor(t / s) + ((Math.cos(Math.PI * (s - (t % s)) / s) + 1) / 2)) / Segments;
  return Math.max(Math.min(distanceFraction, 1), 0);
}

let animation =
  {
    target: document.getElementById("Block_CustomEasing"),
    feature: "left",
    unit: "px",
    applicator: Concert.Applicators.Style,
    easing: triplePiston,
    keyframes: { times: [0, 1500], values: [0, 360] }
  };

var sequence = new Concert.Sequence();
sequence.addTransformations(animation);

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
</code></pre>
			</p>
			<p>
				Don't worry about the mathematics used to calculate the distance fraction.
				The point here isn't to understand how this particular easing function works,
				but to understand how custom easing functions can be constructed and used.
				Simply note that the function <code>triplePiston</code> takes a start time,
				and end time, and a current time, and from that it calculates a return value
				which is a fraction representing the proportion of the total distance the box
				should have moved during the time which has passed so far.
			</p>
			<p>
				How is it used? As you can see above, everything is exactly the same as in previous
				examples except that the transformation set definition's <code>easing</code> property
				is now set to the custom <code>triplePiston</code> function. Then we simply set
				the animation in motion as usual, and our custom function gets used internally
				by Concert.js during the animation for determining where to place the sliding box.
			</p>
			<p>
				Custom easing functions can work any way you like.
				Just remember that they can be called many times per second in a running animation,
				so how quickly they run can have an effect on how smoothly your animation runs.
			</p>
		</div>

		<p class="PreviousTutorialLink">
			<a href="tutorial01.html">Previous: 01 - Sequences and Transformations</a>
		</p>
		<p class="NextTutorialLink">
			<a href="tutorial03.html">Next: 03 - Calculators</a>
		</p>
	</div>
</template:data>


<!-- ================================================================= -->
<!-- TUTORIAL 03: Calculators -->
<template:data target="tutorial03.html" section="MainContent">
	<div>
		<div class="TutorialNavigation">
			<ol>
				<li><a href="tutorial01.html">Sequences and Transformations</a></li>
				<li><a href="tutorial02.html">Easing Functions</a></li>
				<li><strong>Calculators</strong></li>
				<li><a href="tutorial04.html">Applicators</a></li>
				<li><a href="tutorial05.html">Setting Defaults</a></li>
				<li><a href="tutorial06.html">Starting, Stopping, Seeking, and Synchronizing</a></li>
				<li><a href="tutorial07.html">Repeating</a></li>
				<li><a href="tutorial08.html">Cloning and Retargeting</a></li>
				<li><a href="tutorial09.html">Indexing, Value Generator Functions</a></li>
				</ol>
		</div>
		<div class="TutorialIntroSection">
			<h2>Calculators</h2>
			<p>
				A <em>calculator</em> is a function which looks at the start and end values of a target feature
				and calculates the current value to apply.
			</p>
			<p>
				In other words, the calculator function is what determines interpolated values to apply between keyframes.
			</p>
			<p>
				Concert.js has four built-in calculator functions, allowing animation of several types of values.
			</p>
		</div>

		<div class="TutorialStep"> <!-- A Basic Explanation of Calculators -->
			<h4>A Basic Explanation of Calculators</h4>
			<p>
				The first thing to understand about calculator functions is that they are
				not the same thing as easing functions. Some animation libraries combine these two concepts,
				but they are really two separate things.
				<ul>
					<li>
						<strong>Easing Functions:</strong>
						An easing function takes the start time, the end time, and the current time,
						and it decides how far along the animation path the transformation has proceeded.
						<br>
						For instance, the <code>Concert.EasingFunctions.ConstantRate</code> function would calculate that
						if 25% of the time has passed, then the animation should be 25% of the way along,
						and therefore return 0.25.
					</li>
					<li>
						<strong>Calculator Functions:</strong>
						A calculator function then takes the distance fraction calculated by the easing function,
						along with a start and end value (and optionally additional properties that we don't need
						to worry about here), and figures out what the actual interpolated value is which should be
						applied to the target object feature.
						<br>
						For instance, the simplest one, <code>Concert.Calculators.Linear</code>
						(which is also the default if none is specified), just takes two numbers as the start and end values,
						and returns a value in between according to the specified distance fraction.
						That is, if the distance fraction calculated by the easing function is 0.5, the start value is 6,
						and the end value is 8, then the Linear calculator will return 7 (halfway between the start and end).
					</li>
				</ul>
			</p>
			<p>
				Why does this have a separate function? Because not all things animated are simple numeric values.
				Concert.js can animate more complex things as well, like text content, or color values, which are not
				simple points along a number line.
			</p>
		</div>

		<div class="TutorialStep"> <!-- The Built-in Calculator Functions -->
			<h4>The Built-in Calculator Functions</h4>
			<p>
				There are four pre-built calculator functions:
				<ul>
					<li>
						<code>Concert.Calculators.Color</code>:
						The Color calculator allows for smoothly animating color transitions, including alpha channel (transparency) values.
						This function takes start and end values in the form of CSS color style value strings, specified
						in any of hex, rgb, rgba, hsl, or hsla format (start and end values must be in the same format as each other).
						It returns a color string in the same format, interpolated between the start and end values.
					</li>
					<li>
						<code>Concert.Calculators.Discrete</code>:
						The Discrete calculator can take any type of start and end value. It does no interpolation at all,
						simply returning the start value if the transformation hasn't reached the end yet,
						or the end value if it has. This calculator is good for things like changing text strings,
						where interpolation makes no sense, or for animating numeric values that are meant to jump
						from one value to another rather than be interpolated.
					</li>
					<li>
						<code>Concert.Calculators.Linear</code>:
						The Linear calculator simply calculates a linear interpolation between two numeric values.
					</li>
					<li>
						<code>Concert.Calculators.Rotational</code>:
						The Rotational calculator calculates a set of coordinates resulting from rotational motion.
						Its start and end values are objects that define the start and end points of rotational motion,
						and the calculator function will interpolate between those, returning coordinates in the form <code>[left, top]</code>.
					</li>
				</ul>
			</p>
			<p>
				Below is an example that uses all four:
			</p>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame TallDemoFrame" src="TutorialExamples/Page03Example01.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page03Example01.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				<pre><code>const Sun = document.getElementById("Sun"),
  Neptune = document.getElementById("Neptune"),
  OrbitTime = 2000, Orbits = 4,
  CaptionBox = document.getElementById("Caption");

let animations =
[
  {
    target: Neptune,
    feature: ["left", "top"],
    unit: "px",
    applicator: Concert.Applicators.Style,
    calculator: Concert.Calculators.Rotational,
    keyframes:
    {
      times: [0, Orbits * OrbitTime],
      values:
      [
        {
          centerX: 240, centerY: 130,
          radius: 100, angle: 0,
          offsetX: -10, offsetY: -10
        },
        {
          centerX: 240, centerY: 130,
          radius: 100, angle: Orbits * 2 * Math.PI,
          offsetX: -10, offsetY: -10
        }
      ]
    }
  },

  {
    target: Sun,
    feature: ["left", "top", "width", "height"],
    unit: "px",
    applicator: Concert.Applicators.Style,
    calculator: Concert.Calculators.Linear,
    keyframes:
    {
      times: [OrbitTime, 2 * OrbitTime, 3 * OrbitTime],
      values:
      [
        [215, 105, 50, 50],
        [220, 110, 40, 40],
        [185, 75, 110, 110]
      ]
    }
  },

  {
    target: Sun,
    feature: "background-color",
    unit: null,
    applicator: Concert.Applicators.Style,
    calculator: Concert.Calculators.Color,
    keyframes:
    {
      times: [OrbitTime, 2 * OrbitTime, 3 * OrbitTime],
      values: ["#ffff00", "#ffffcc", "#aa0000"]
    }
  },

  {
    target: CaptionBox,
    feature: "innerHTML",
    applicator: Concert.Applicators.Property,
    calculator: Concert.Calculators.Discrete,
    keyframes:
    {
      times: [0, OrbitTime, 3 * OrbitTime],
      values: ["Main Sequence Star", "Transition", "Red Giant"]
    }
  }
];

let sequence = new Concert.Sequence();
sequence.addTransformations(animations);

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
</code></pre>
			</p>
			<p>
				The above code defines four distinct animations.
			</p>
			<p>
				The first applies to a <code>div</code> with the ID "Neptune".
				It modifies the <code>left</code> and <code>top</code> CSS properties,
				and it does so using the <code>Rotational</code> calculator.
				When run, this causes the div to move in a rotational pattern around the defined center point.
				You may have noticed that the keyframe values given to it include 6 properties.
				All of them can be animated. Here we only are animating the angle,
				but it is possible to animate the center point, the radius, and the offset values as well.
				(The offsetX and offsetY values are adjustments added to the final, calculated coordinates.
				Remember that CSS positions define an element's top, left corner. Often what you really want
				in rotational motion is not to orbit the top, left corner of an object around a center point,
				but to orbit the center of that object around the center point. The offset values move the calculator's
				output over and therefore can adjust for that problem.)
			</p>
			<p>
				The second animation uses the <code>Linear</code> calculator to adjust four style properties
				of the "Sun" object: <code>left</code>, <code>top</code>, <code>width</code>, and <code>height</code>.
				This is very similar to animations we've seen in previous steps of this tutorial.
			</p>
			<p>
				The third animation introduces the <code>Color</code> calculator.
				This one modifies the <code>background-color</code> style of the "Sun" object.
				Three keyframes are defined. At the first, the color is "#ffff00" (yellow).
				Between the first and second keyframes, the color will gradually fade to the second value: "#ffffcc" (whitish-yellow),
				and then finally between the second and third keyframes the color fades to "#aa0000" (red).
				If we preferred, we could have used "rgb(255, 255, 0)" or rgba, hsl, or hsla equivalents instead.
			</p>
			<p>
				The fourth animation uses the <code>Discrete</code> calculator.
				This simply maintains each value unchanged until the next keyframe hits,
				then applies the next value and maintains that, and so on.
				<br>
				Note: If you're paying attention closely, you'll have spotted that this transformation definition
				also uses a new applicator, <code>Concert.Applicators.Property</code>.
				This is needed for reasons that will become clear in the next tutorial step,
				where applicator functions are discussed.
			</p>
		</div>

		<div class="TutorialStep"> <!-- Custom Calculator Functions-->
			<h4>Custom Calculator Functions</h4>
			<p>
				You are not limited to the built-in calculator functions.
				As with easing functions, user-provided calculator functions are easy to integrate with Concert.js.
				If you wish to calculate and apply complex numbers, object values, arrays of values,
				calculate values based on dynamically obtained values from user input, 
				or accomplish some other task needed for your animation,
				you can supply your own function used for calculations.
			</p>
			<p>
				A calculator function is any function with the following signature:
				<br>
				<code>calculatorFunction(distanceFraction, startValue, endValue, addlProperties)</code>
				<br>
				The distance fraction is a numeric value where 0 is the starting point (where the start value should be returned),
				and 1 is end ending point (where the end value should be returned). Use any method you like for generating
				the in-between value; just make sure that the value returned is one that the applicator function in use handles properly.
				(Applicator functions are discussed in the next step of this tutorial.)
				It is also possible to attach additional, custom properties to a sequence object or to the transformations within it,
				in the case where some kind of extra data is needed to carry out the animation.
				Those additional properties, if present, will be passed into any custom calculator function using the <code>addlProperties</code> argument.
			</p>
			<p>
				Custom calculators can work any way you like. Just remember that they can be called many times per second in a running animation,
				so how quickly they run can have an effect on how smoothly your animation runs.
			</p>
		</div>

		<p class="PreviousTutorialLink">
			<a href="tutorial02.html">Previous: 02 - Easing Functions</a>
		</p>
		<p class="NextTutorialLink">
			<a href="tutorial04.html">Next: 04 - Applicators</a>
		</p>
	</div>
</template:data>


<!-- ================================================================= -->
<!-- TUTORIAL 04: Applicators -->
<template:data target="tutorial04.html" section="MainContent">
	<div>
		<div class="TutorialNavigation">
			<ol>
				<li><a href="tutorial01.html">Sequences and Transformations</a></li>
				<li><a href="tutorial02.html">Easing Functions</a></li>
				<li><a href="tutorial03.html">Calculators</a></li>
				<li><strong>Applicators</strong></li>
				<li><a href="tutorial05.html">Setting Defaults</a></li>
				<li><a href="tutorial06.html">Starting, Stopping, Seeking, and Synchronizing</a></li>
				<li><a href="tutorial07.html">Repeating</a></li>
				<li><a href="tutorial08.html">Cloning and Retargeting</a></li>
				<li><a href="tutorial09.html">Indexing, Value Generator Functions</a></li>
				</ol>
		</div>
		<div class="TutorialIntroSection">
			<h2>Applicators</h2>
			<p>
				An <em>applicator</em> is a function which takes whatever value is calculated by the combination of the
				easing function and the calculator function, and actually applies it to the target.
			</p>
			<p>
				That is, if a sequence is animating the <code>left</code> style property of a moving object,
				the applicator function is what actually sets the <code>left</code> value.
			</p>
			<p>
				Concert.js has three built-in applicators for use in the most common situations.
				As with easing functions and calculator functions, custom applicators can be used as well.
			</p>
		</div>

		<div class="TutorialStep"> <!-- A Basic Explanation of Applicators -->
			<h4>A Basic Explanation of Applicators</h4>
			<p>
				The purpose of an applicator function is to take the value applicable to the present frame
				and apply it to the object being manipulated by the animation.
			</p>
			<p>
				Because Concert.js can be used to animate just about anything, it is necessary to be able to
				apply all kinds of values to all kinds of objects. The values might be CSS styles, or innerHTML text content,
				for instance, or some kind of complex, user-defined object that needs to be mapped in a custom way
				to whatever is being manipulated in the animation sequence.
			</p>
		</div>

		<div class="TutorialStep"> <!-- The Built-in Applicator Functions -->
			<h4>The Built-in Applicator Functions</h4>
			<p>
				There are three built-in applicator functions:
				<ul>
					<li>
						<code>Concert.Applicators.Property</code>:
						The Property applicator simply takes whatever value is passed to it and applies it to the target object
						feature, treating the feature as a <em>property</em> of the object.
						That is, if the object being animated is an object <code>captionDiv</code>,
						the target feature is <code>"innerHTML"</code>, and the value being applied is <code>"caption text"</code>,
						it will simply result in the equivalent of the following value assignment:<br>
						<code>captionDiv.innerHTML = "caption text";</code><br>
						The Property applicator is the default, used if none is specified and the default isn't changed.
					</li>
					<li>
						<code>Concert.Calculators.Style</code>:
						The Style applicator takes the value passed to it and applies it to the target object feature,
						treating the feature as a <em>CSS style property</em>.
						That is, if the object being animated is is an object <code>colorDiv</code>,
						the target feature is <code>"background-color"</code>,
						and the value being applied is <code>"rgb(255, 0, 0)"</code>,
						it will result in the equivalent of the following value assignment:<br>
						<code>colorDiv.style.backgroundColor = "rgb(255, 0, 0)";</code><br>
						Note that style properties are normalized automatically, so you can specify target features
						which are styles using either their CSS-style name (e.g. <code>background-color</code>)
						or the equivlant JavaScript property-style name (e.g. <code>backgroundColor</code>).
					</li>
					<li>
						<code>Concert.Calculators.SVG_ElementAttribute</code>:
						The SVG_ElementAttribute applicator takes the value passed to it and applies it to the target object feature,
						treating the feature as an <em>attribute</em> of the object.
						That is, if the object being animated is an object <code>svgRect</code>,
						the target feature is <code>width</code>, and the value being applied is <code>90</code>,
						it will result in the equivalent of the following value assignment:<br>
						<code>svgRect.setAttribute("width", 90);</code>
					</li>
				</ul>
			</p>
			<p>
				Below is an example where you can see all three in use:
			</p>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame" src="TutorialExamples/Page04Example01.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page04Example01.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				<pre><code>const WideningDiv = document.getElementById("WideningDiv"),
  WideningSvgRect = document.getElementById("WideningSvgRect"),
  CaptionBox = document.getElementById("Caption");

let animations =
  [
    {
      target: WideningDiv,
      feature: "width",
      unit: "px",
      applicator: Concert.Applicators.Style,
      calculator: Concert.Calculators.Linear,
      keyframes: { times: [0, 1500], values: [100, 480] }
    },

    {
      target: WideningSvgRect,
      feature: "width",
      unit: "px",
      applicator: Concert.Applicators.SVG_ElementAttribute,
      calculator: Concert.Calculators.Linear,
      keyframes: { times: [0, 1500], values: [100, 480] }
    },

    {
      target: CaptionBox,
      feature: "innerHTML",
      unit: null,
      applicator: Concert.Applicators.Property,
      calculator: Concert.Calculators.Discrete,
      keyframes:
      {
        times: [0, 750, 1500],
        values: ["Start Value", "Midpoint Value", "End Value"]
      }
    }
  ];

let sequence = new Concert.Sequence();
sequence.addTransformations(animations);

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
</code></pre>
			</p>
			<p>
				The first two transformation definitions above are nearly identical.
				The first is just like many we have seen in earlier steps of this tutorial.
				But SVG objects don't get altered in quite the same way as regular HTML elements,
				so to accomplish the same width-altering animation with the SVG <code>rect</code>,
				we use a different applicator: <code>Concert.Applicators.SVG_ElementAttribute</code>.
				Everything else about this transformation works exactly the same.
			</p>
			<p>
				The third transformation is on the caption box. To change the text inside the <code>div</code> element,
				we're just changing the <code>innerHTML</code> property. This is not a style, but a direct property of the
				<code>div</code> object, so the applicator used in most of the examples up to now does not apply.
				Instead, we use the <code>Concert.Applicators.Property</code> applicator.
				(You will probably also note that we used the <code>Concert.Calculators.Discrete</code> calculator here,
				because our usual calculator, <code>Concert.Calculators.Linear</code>, tries to interpolate between
				start and end values, which makes no sense in the case of wholesale text replacement.)
			</p>
		</div>
	
		<div class="TutorialStep"> <!-- Custom Applicator Functions-->
			<h4>Custom Applicator Functions</h4>
			<p>
				You are not limited to the built-in applicator functions.
				As with easing functions, and calculator functions,
				user-provided applicator functions are easy to integrate with Concert.js.
				If you wish to apply complex numbers, object values, arrays of values,
				or make use of any other type of value or target object and feature other than those
				handled by the defaults, you can supply your own function that will be called
				on each frame when it is time to apply a new value to the animated target.
			</p>
			<p>
				An applicator function is any function with the following signature:
				<br>
				<code>function applicatorFunction(target, feature, value, unit)</code>
				<br>
				The target passed in is the object being modified by the animation sequence.<br>
				The feature passed in is the property being manipulated on that object.<br>
				The value passed in is the new thing the applicator function should apply to the target object.<br>
				The unit passed in is the unit which should be attached to the value.
				(For example, for CSS styles, this is often "px", or "%", or some other unit applicable to element styles.
				But in many cases, a unit isn't applicable at all, and this value may be null.)<br>
				No return value is expected.
			</p>
			<p>
				Your custom function should be able to handle the values passed it by the sequence you define and apply them to the target objects.<br>
				It can do whatever you like; just do be aware that this function may get called many times per second, and so its speed does matter.
			</p>
		</div>

		<p class="PreviousTutorialLink">
			<a href="tutorial03.html">Previous: 03 - Calculators</a>
		</p>
		<p class="NextTutorialLink">
			<a href="tutorial05.html">Next: 05 - Setting Defaults</a>
		</p>
	</div>
</template:data>


<!-- ================================================================= -->
<!-- TUTORIAL 05: Setting Defaults -->
<template:data target="tutorial05.html" section="MainContent">
	<div>
		<div class="TutorialNavigation">
			<ol>
				<li><a href="tutorial01.html">Sequences and Transformations</a></li>
				<li><a href="tutorial02.html">Easing Functions</a></li>
				<li><a href="tutorial03.html">Calculators</a></li>
				<li><a href="tutorial04.html">Applicators</a></li>
				<li><strong>Setting Defaults</strong></li>
				<li><a href="tutorial06.html">Starting, Stopping, Seeking, and Synchronizing</a></li>
				<li><a href="tutorial07.html">Repeating</a></li>
				<li><a href="tutorial08.html">Cloning and Retargeting</a></li>
				<li><a href="tutorial09.html">Indexing, Value Generator Functions</a></li>
				</ol>
		</div>
		<div class="TutorialIntroSection">
			<h2>Setting Defaults</h2>
			<p>
				It is often the case that many transformation sets need to be added to a sequence all or most of which
				share many settings. More efficient than specifying the same values over and over again is using
				default values.
			</p>
		</div>

		<div class="TutorialStep"> <!-- How to Set and Use Defaults -->
			<h4>How to Set and Use Defaults</h4>
			<p>
				The <code>Concert.Sequence</code> object provides a method called <code>setDefaults()</code>,
				which allows setting a sequence's default applicator, calculator, easing function, and unit.
				Those defaults are applied to all subsequently added transformations that do not explicitly specify those things
				in their own definitions.
			</p>
			<p>
				<code>setDefaults</code> takes a single argument, an object which looks like this:<code><pre>
{
  applicator: VALUE,
  calculator: VALUE,
  easing: VALUE,
  unit: VALUE
}</pre></code>
			</p>
			<p>
				Any or all of the above properties can be specified, and only those specified are set.
				(That is, if the default calculator is already <code>Concert.Calculators.Rotational</code>,
				and <code>setDefaults</code> is called again to change the default easing function but
				a new default calculator is not specified, then the sequence's default calculator
				will remain set to <code>Concert.Calculators.Rotational</code>.)
			</p>
			<p>
				<strong>Important note:</strong>
				Transformations are given their applicator, calculator, easing function, and unit
				<em>at the time they are added to the sequence</em>. Setting new defaults therefore
				will only affect transformations added to the sequence <em>after</em> the new defaults
				are set. The <code>setDefaults()</code> method never changes transformations already added.
			</p>
			<p>
				Below see an example of setting defaults to avoid code duplication:
			</p>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame" src="TutorialExamples/Page05Example01.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page05Example01.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				<pre><code>const WideningDiv1 = document.getElementById("WideningDiv1"),
  WideningDiv2 = document.getElementById("WideningDiv2"),
  WideningDiv3 = document.getElementById("WideningDiv3");

let sequence = new Concert.Sequence();

sequence.setDefaults(
  {
    applicator: Concert.Applicators.Style,
    calculator: Concert.Calculators.Linear,
    easing: Concert.EasingFunctions.QuadInOut,
    unit: "px",
  });

let animations =
  [
    {
      target: WideningDiv1, feature: "width",
      keyframes: { times: [0, 1500], values: [120, 480] }
    },

    {
      target: WideningDiv2, feature: "width",
      keyframes: { times: [0, 1500], values: [120, 480] }
    },

    {
      target: WideningDiv3, feature: "width",
      unit: "%",
      keyframes: { times: [0, 1500], values: [25, 100] }
    }
  ];

sequence.addTransformations(animations);

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
</code></pre>
			</p>
			<p>
				The above defines three transformations. But because the call to <code>setDefaults()</code>
				has defined default values for applicator, calculator, easing function, and unit,
				none of those three things need to be declared in the transformation definitions themselves
				if those default values are what is needed. Note that the third transformation above
				(which specifies a "%" unit instead of using "px" like the others) demonstrates
				how it is perfectly possible to use values other than the defaults if you want.
			</p>
		</div>

		<div class="TutorialStep"> <!-- Pre-defined Defaults -->
			<h4>Pre-defined Defaults</h4>
			<p>
				We have been explicitly declaring values for most of these parameters in this tutorial sequence so far,
				but that was just to show how things work. There are initial default values which you can rely upon
				as well, specifying only those parameters which differ from those defaults.
			</p>
			<p>
				Here is what the defaults are set to automatically in a newly created Concert.Sequence object:
			</p>
			<p>
				<code>applicator: Concert.Applicators.Property</code><br>
				<code>calculator: Concert.Calculators.Linear</code><br>
				<code>easing: Concert.EasingFunctions.ConstantRate</code><br>
				<code>unit: null</code>
			</p>
		</div>

		<p class="PreviousTutorialLink">
			<a href="tutorial04.html">Previous: 04 - Applicators</a>
		</p>
		<p class="NextTutorialLink">
			<a href="tutorial06.html">Next: 06 - Starting, Stopping, Seeking, and Synchronizing</a>
		</p>
	</div>
</template:data>


<!-- ================================================================= -->
<!-- TUTORIAL 06: Starting, Stopping, Seeking, and Synchronizing -->
<template:data target="tutorial06.html" section="MainContent">
	<div>
		<div class="TutorialNavigation">
			<ol>
				<li><a href="tutorial01.html">Sequences and Transformations</a></li>
				<li><a href="tutorial02.html">Easing Functions</a></li>
				<li><a href="tutorial03.html">Calculators</a></li>
				<li><a href="tutorial04.html">Applicators</a></li>
				<li><a href="tutorial05.html">Setting Defaults</a></li>
				<li><strong>Starting, Stopping, Seeking, and Synchronizing</strong></li>
				<li><a href="tutorial07.html">Repeating</a></li>
				<li><a href="tutorial08.html">Cloning and Retargeting</a></li>
				<li><a href="tutorial09.html">Indexing, Value Generator Functions</a></li>
				</ol>
		</div>
		<div class="TutorialIntroSection">
			<h2>Starting, Stopping, Seeking, and Synchronizing</h2>
			<p>
				There are a number of options for how to start and move around in an animation sequence,
				including the possibility of synchronizing it to other things (e.g., video or audio,
				other Concert.js sequences, or user controls).
			</p>
			<p>
				See below to learn how to use some of these possibilities.
			</p>
		</div>

		<div class="TutorialStep"> <!-- The Basics of Running Sequences -->
			<h4>The Basics of Running Sequences</h4>
			<p>
				So far, we've run sequences using the <code>begin()</code> method.
				We will examine that function shortly.
				First let's take a step back and look at a more general function for running Concert.js sequences.
			</p>
			<p>
				The fundamental method for making a sequence go is the <code>run()</code> method.
				The <code>run()</code> method takes a single, optional parameter, an object which can have
				any or all of a number of properties. For a full explanation, see the <a href="Reference/index.html">Reference documentation</a>.
				But here is a rough overview of them all.
			</p>
			<p>
				<ul>
					<li>
						<code>after</code>:
						This specifies what to do upon reaching the end of the sequence timeline.
						It will be covered in the <a href="tutorial07.html">tutorial step on Repeating</a>.</li>
					<li>
						<code>autoStopAtEnd</code>:
						This specifies whether to automatically stop running the sequence when it hits the end.
						Defaults to <code>true</code>.
					</li>
					<li>
						<code>before</code>:
						This specifies what to do when encountering time values before the beginning of the sequence timeline.
						It will be covered in the <a href="tutorial07.html">tutorial step on Repeating</a>.</li>
					</li>
					<li>
						<code>generateValues</code>:
						Transformations can have start and end values that are dynamically generated at some later point rather than
						being fixed at the time they are added to the sequence. This parameter specifies whether the sequence should
						calculate all those values automatically just before running the animation.
						This feature is covered in <a href="tutorial08.html">tutorial step on Indexing and Value Generators</a>.
						Defaults to <code>true</code>.
					</li>
					<li>
						<code>initialSeek</code>:
						Numeric value indicating an intial seek point along the timeline.
						This allows starting a sequence from some point other than the beginning.
						If a non-null value is given for this parameter, the sequence will seek to the specified time before commencing the run.
					</li>
					<li>
						<code>onAutoStop</code>:
						This allows you to specify a callback function that will be invoked just after automatically stopping at the end of the sequence.
						Note that it will only ever be called if the <code>autoStopAtEnd</code> parameter mentioned above is set to <code>true</code>.
					</li>
					<li>
						<code>pollingInterval</code>:
						Numeric value indicating the time in between animation updates. This allows you to manually set how far apart (in milliseconds)
						the beginnings of successive frames of the animation are. When set to any value below 1 (0 is the default),
						Concert will handle this automatically using <code>window.requestAnimationFrame()</code>.
					</li>
					<li>
						<code>speed</code>:
						Numeric value indicating a run speed multiplier (0.5 = half-speed, 2 = double-speed, and so on).
					</li>
					<li>
						<code>stretchStartTimeToZero</code>:
						As will be explained in the <a href="tutorial07.html">tutorial step on Repeating</a>, various behaviors can be set to occur
						when the time goes past the end of the timeline, or before it reaches the beginning of it.
						If the first segment of animation begins at some time later than 0, however, this can bring about unexpected triggering of
						the sequence's "before" behavior or auto-stop when the sequence is run from time 0, since that is technically before the beginning
						of the sequence. Sometimes it is therefore useful for the sequence to behave as if the start point of the whole sequence is at time 0,
						even when the first segment of animation actually begins later than this.
						If <code>stretchStartTimeToZero</code> is set to <code>true</code>, the sequence will act as though its overall start is at time 0.
					</li>
					<li>
						<code>synchronizeTo</code>:
						This allows setting a synchronization source for the sequence. It can take any of the following:
						<ul>
							<li><code>null</code>: The sequence will be locked to the system clock.</li>
							<li>
								A <code>function</code> object:
								The sequence will call this function every time the polling interval is reached, and the function's
								return value will be used as the current time to seek to.
								Using a custom function here allows you to synchronize the sequence to anything you want
								(for instance, locking it to the current value of a UI element, such as a slider,
								or to another <code>Concert.Sequence</code> object.)
							</li>
							<li>
								An HTML <code>audio</code> or <code>video</code> DOM object:
								The sequence will be locked to the <code>currentTime</code> property of the media element (converted to milliseconds).
								This allows the sequence to remain synchronized to a media element even when it is paused, scrubbed, or the user skips around.
							</li>
						</ul>
					</li>
					<li>
						<code>timeOffset</code>:
						Numeric value indicating a constant value to be added to the current time before seeking.
						This is useful if you want your sequence to run a fixed amount ahead of or behind your synchronization source.
						If it is <code>null</code>, the value is calculated automatically, assuming you intend for the current sequence seek time
						to be matched to the current position of the synchronization source.
					</li>
					<li>
						<code>useSoleControlOptimization</code>:
						Boolean value, indicating whether the sequence can assume it is the only thing controlling
						all the object properties it is modifying while running.
						Setting it to <code>true</code> allows Concert.js to make optimizations that speed up seek times and therefore improve performance.
						But if anything else will be touching the features being animated, this should be set to <code>false</code>.
					</li>
				</ul>
			</p>
		</div>

		<div class="TutorialStep"> <!-- Auxiliary Control Methods -->
			<h4>Auxiliary Control Methods</h4>
			<p>
				There are several shortcut methods which can be used for making a sequence run, along with several other useful, related functions.
				These can be seen in the below example. If you experiment with the buttons on this demo, you can see how the different functions work.
				<ul>
					<li>
						<strong>begin</strong>:
						Try clicking this button at any time. You'll see the yellow box start at the beginning and move to the end,
						without regard for whether the video is running.
					</li>
					<li>
						<strong>follow</strong>:
						Try starting the video, and then clicking the "follow" button.
						You'll notice that the yellow box moves in sync with the video, but offset by whatever position the video was in when
						the follow button was clicked.
					</li>
					<li>
						<strong>syncTo</strong>:
						Try clicking the "syncTo" button before or after starting the video.
						You'll see that the yellow box moves in sync with the video as with "follow", except that it jumps
						to the position the video is in (that is, it is like "follow" with an offset of 0).
					</li>
					<li>
						<strong>stop</strong>: The <code>stop()</code> method will stop a sequence at any time.
					</li>
					<li>
						<strong>seek</strong>:
						Try entering a time value in millseconds (0-5000 is the range of this animation),
						then hitting the "seek" button. You'll see the yellow box immediately jump to whatever time position you specified--
						unless the animation is already running, in which case your seek will be overridden so fast you probably won't see
						it happen at all.
					</li>
				</ul>
			</p>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame TallDemoFrame" src="TutorialExamples/Page06Example01.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page06Example01.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				You also may notice that in this case the sequence does not stop running automatically when using <code>syncTo</code>
				or <code>follow</code>. This allows you to scrub the video back and forth even after it is finished, or restart it, and
				the sequence is still locked to it. It does mean that the poller is still running, though, and continually updating
				the position of the yellow box. In many cases that is an unnecessary waste of processing, and it is only done here to
				demonstrate how these functions work. Often a better route would be to set <code>onplay</code>, <code>onpause</code>,
				and <code>onseeked</code> event handlers to run the sequence's <code>syncTo()</code>, <code>stop()</code>,
				and <code>seek()</code> methods, respectively.
			</p>
			<p>
				Below is the source code for this example. In comments it shows how the various sequence start methods are all just shortcuts
				for common ways of calling the <code>run()</code> method.
				<pre><code>const BeginButton = document.getElementById("BeginButton"),
  FollowButton = document.getElementById("FollowButton"),
  SyncToButton = document.getElementById("SyncToButton"),
  StopButton =  document.getElementById("StopButton"),
  VideoElement = document.getElementById("MovingBoxVideo"),
  MovingBox = document.getElementById("MovingBox"),
  StatusBox = document.getElementById("StatusBox"),
  SeekInput = document.getElementById("SeekInput"),
  SeekButton =  document.getElementById("SeekButton");

function showStatus(isRunning)
{ StatusBox.innerHTML = "Running: " + (isRunning === true); }

let sequence = new Concert.Sequence();
sequence.setDefaults({ applicator: Concert.Applicators.Style, unit: "px" });

let animation =
{
  target: MovingBox, feature: "left",
  keyframes: { times: [0, 5000], values: [0, 270] }
};

let params = { onAutoStop: function() { showStatus(false); } };

sequence.addTransformations(animation);

BeginButton.onclick =
  function ()
  {
    showStatus(true);

    sequence.begin(params);
    // equivalent to:
    //   sequence.run(
    //   {
    //     synchronizeTo: null, initialSeek: 0,
    //     timeOffset: null, autoStopAtEnd: true,
    //     [plus whatever properties are set in the params variable]
    //   });
  };

FollowButton.onclick =
  function ()
  {
    showStatus(true);

    sequence.follow(VideoElement, params);
    // equivalent to:
    //   sequence.run(
    //	 {
    //     synchronizeTo: VideoElement, initialSeek: null,
    //     timeOffset: null, autoStopAtEnd: false,
    //     [plus whatever properties are set in the params variable]
    //   });
  };

SyncToButton.onclick =
  function ()
  {
    showStatus(true);
    
    sequence.syncTo(VideoElement, params);
    // equivalent to:
    //   sequence.run(
    //	 {
    //     synchronizeTo: VideoElement, initialSeek: null,
    //     timeOffset: 0, autoStopAtEnd: false,
    //     [plus whatever properties are set in the params variable]
    //   });
  };

StopButton.onclick = function () { sequence.stop(); showStatus(false); };

SeekButton.onclick =
  function ()
  {
    let position = parseInt(SeekInput.value);
    sequence.seek(isNaN(position) ? 0 : position);
  };

SeekInput.onkeyup =
  function (event)
  {
    if (event.keyCode === 13)
      SeekButton.click();
  };</code></pre>
			</p>
			<p>
				A few more functions that may come in handy occasionally are:
	 			<ul>
					 <li>
						 <code>getCurrentTime()</code>, which gets the current position along a sequence's timeline.
					 </li>
					 <li>
						 <code>getStartTime()</code>, which gets the start time of a sequence's timeline.
						 (The start time of a sequence is considered to be the first start time of any transformation within that sequence.)
					 </li>
					 <li>
						<code>getEndTime()</code>, which gets the end time of a sequence's timeline.
						(The end time of a sequence is considered to be the last end time of any transformation within that sequence.)
					 </li>
					 <li>
						<code>isRunning()</code>, which returns a Boolean value indicating whether the sequence is presently running.
					 </li>
				</ul>
			</p>
		</div>

		<p class="PreviousTutorialLink">
			<a href="tutorial05.html">Previous: 05 - Setting Defaults</a>
		</p>
		<p class="NextTutorialLink">
			<a href="tutorial07.html">Next: 07 - Repeating</a>
		</p>
	</div>
</template:data>


<!-- ================================================================= -->
<!-- TUTORIAL 07: Repeating -->
<template:data target="tutorial07.html" section="MainContent">
	<div>
		<div class="TutorialNavigation">
			<ol>
				<li><a href="tutorial01.html">Sequences and Transformations</a></li>
				<li><a href="tutorial02.html">Easing Functions</a></li>
				<li><a href="tutorial03.html">Calculators</a></li>
				<li><a href="tutorial04.html">Applicators</a></li>
				<li><a href="tutorial05.html">Setting Defaults</a></li>
				<li><a href="tutorial06.html">Starting, Stopping, Seeking, and Synchronizing</a></li>
				<li><strong>Repeating</strong></li>
				<li><a href="tutorial08.html">Cloning and Retargeting</a></li>
				<li><a href="tutorial09.html">Indexing, Value Generator Functions</a></li>
				</ol>
		</div>
		<div class="TutorialIntroSection">
			<h2>Repeating</h2>
			<p>
				It may be desireable for a sequence to keep doing something past its end, or before its beginning (for instance, loop a certain number of times).
			</p>
			<p>
				See below to learn how.
			</p>
		</div>

		<div class="TutorialStep"> <!-- Repeat Behaviors -->
			<h4>Repeat Behaviors</h4>
			<p>
				All the animations we've seen so far just run from the beginning to the end.
				But what if you'd like the same thing to happen more than once, or bounce back and forth,
				without having to suplicate all the more segments or keyframes again and again?
			</p>
			<p>
				A sequence has two behavioral properties you can set to define how it acts past the end
				and before the beginning of the defined timeline. Each of these can be set to three different values.
			</p>
			<p>
				See these in action in the below example:
			</p>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame" src="TutorialExamples/Page07Example01.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page07Example01.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				<pre><code>const SegmentDuration = 1250, MovementDistance = 240,
    Box0 = document.getElementById("Box0"),
    Box1 = document.getElementById("Box1"),
    Defaults =
    {
      applicator: Concert.Applicators.Style,
      easing: Concert.EasingFunctions.ConstantRate,
      unit: "px"
    };

let bounceSequence = new Concert.Sequence(),
  loopSequence = new Concert.Sequence();

bounceSequence.setDefaults(Defaults);
loopSequence.setDefaults(Defaults);

bounceSequence.addTransformations(
  {
    target: Box0,
    feature: "left",
    keyframes: { times: [0, SegmentDuration], values: [0, MovementDistance] }
  });

loopSequence.addTransformations(
  {
    target: Box1,
    feature: "left",
    keyframes: { times: [0, SegmentDuration], values: [0, MovementDistance] }
  });

document.getElementById("GoButton").onclick =
  function ()
  {
    bounceSequence.begin({ after: Concert.Repeating.Bounce(4) });
    loopSequence.begin({ after: Concert.Repeating.Loop(4) });
  };</code></pre>
			</p>
			<p>
				The above code creates two Concert.Sequence objects.
				Each has an identical animation, but one is begun with an <code>after</code> parameter of
				<code>Concert.Repeating.Bounce(4)</code>, and the other is given an <code>after</code> value of
				<code>Concert.Repeating.Loop(4)</code>.
			</p>
			<p>
				Let's see what the different possible values mean that can be specified here.
				<ul>
					<li>
						<code>Concert.Repeating.None</code>: This is the default. If the current time is before the start time,
						the value set is the start value. If the current time is after the end time, the value set is the end value.
					</li>
					<li>
						<code>Concert.Repeating.Bounce(bounceCount)</code>: This causes the sequence to alternate between running
						forward and running in reverse. The <code>bounceCount</code> parameter tells it how many times to bounce
						back the other way. (That is, a value of 0 would mean nothing extra happens at all, a value of 1 would
						mean a single run-through in the opposite direction, and so on.)
					</li>
					<li>
						<code>Concert.Repeating.Loop(loopbackCount)</code>: This causes the sequence to repeat in the forward direction
						the specified number of times. The <code>loopbackCount</code> is the number of times it loops back. (So a value
						of 0 would mean no looping, just playing through once. A value of 1 would mean it plays once then loops back once,
						for 2 total play-throughs, and so on.)
					</li>
				</ul>
			</p>
			<p>
				These values can be specified in two different ways.
			</p>
			<p>
				First, they can be passed in a parameters object to any of the <code>run()</code>-type methods
				(<code>run()</code>, <code>begin()</code>, <code>follow()</code>, or <code>syncTo()</code>),
				as a value given to the <code>before</code> or <code>after</code> properties.
				This is how it is done in the example above.
			</p>
			<p>
				Alternatively, they can be passed ahead of time to the <code>setBefore()</code> or <code>setAfter()</code>
				methods of the sequence object, and then those settings will be used whenever the sequence is run.
			</p>
		</div>

		<p class="PreviousTutorialLink">
			<a href="tutorial06.html">Previous: 06 - Starting, Stopping, Seeking, and Synchronizing</a>
		</p>
		<p class="NextTutorialLink">
			<a href="tutorial08.html">Next: 08 - Cloning and Retargeting</a>
		</p>
	</div>
</template:data>


<!-- ================================================================= -->
<!-- TUTORIAL 08: Cloning and Retargeting -->
<template:data target="tutorial08.html" section="MainContent">
	<div>
		<div class="TutorialNavigation">
			<ol>
				<li><a href="tutorial01.html">Sequences and Transformations</a></li>
				<li><a href="tutorial02.html">Easing Functions</a></li>
				<li><a href="tutorial03.html">Calculators</a></li>
				<li><a href="tutorial04.html">Applicators</a></li>
				<li><a href="tutorial05.html">Setting Defaults</a></li>
				<li><a href="tutorial06.html">Starting, Stopping, Seeking, and Synchronizing</a></li>
				<li><a href="tutorial07.html">Repeating</a></li>
				<li><strong>Cloning and Retargeting</strong></li>
				<li><a href="tutorial09.html">Indexing, Value Generator Functions</a></li>
				</ol>
		</div>
		<div class="TutorialIntroSection">
			<h2>Cloning and Retargeting</h2>
			<p>
				Often it may be useful to define a sequence and then apply it to a new object later,
				or to apply the same sequence to multiple objects.
			</p>
			<p>
				See below to learn how.
			</p>		</div>

		<div class="TutorialStep"> <!-- Retargeting -->
			<h4>Retargeting</h4>
			<p>
				A sequence can be created to animate some feature or set of features on one target object,
				and then later changed so that it animates those features on another.
			</p>
			<p>
				In the below example, try clicking the "Go" button, then clicking the "Retarget" button
				and clicking "Go" again. You will see the sequence is retargeted back and forth between
				the two boxes and the "Go" button causes animation of whichever object is currently
				the sequence's target.
			</p>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame" src="TutorialExamples/Page08Example01.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page08Example01.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				<pre><code>const Box0 = document.getElementById("Box0"),
  Box1 = document.getElementById("Box1");

function newTargetLookup(oldTarget)
{
  let newTarget = (oldTarget.id.slice(-1) === "0") ? Box1 : Box0;
  return newTarget;
}

let sequence = new Concert.Sequence();
sequence.addTransformations(
  {
    target: Box0,
    feature: "top",
    applicator: Concert.Applicators.Style,
    easing: Concert.EasingFunctions.QuadInOut,
    unit: "px",
    keyframes: { times: [0, 1000], values: [0, 100] }
  });

document.getElementById("GoButton").onclick = function () { sequence.begin(); };
document.getElementById("RetargetButton").onclick = function () { sequence.retarget(newTargetLookup); };
</code></pre>
			</p>
			<p>
				The above code creates a single <code>Concert.Sequence</code> object,
				and adds a transformation which changes the value of the "top" style property of Box1
				from 0 to 100 over a time period of 1 second (1000 ms).
			</p>
			<p>
				The <code>onclick</code> event of the "Go" button is set to begin the animation sequence.
			</p>
			<p>
				The <code>onclick</code> event of the "Retarget" button is set to call the sequence's
				<code>retarget()</code> method, passing in the <code>newTargetLookup</code> function.
				The return value of that function is an object which <code>retarget()</code> then assigns
				as the sequence's new target object. All other properties of the sequence remain the same.
				Everything the sequence now does will apply to the new target instead of the old.
			</p>
			<p>
				The <code>newTargetLookup()</code> function gets passed the current target object and can
				therefore use that to decide what the new target should be. In this case, it just checks
				to see which of the two boxes is presently targeted and returns the other one.
			</p>
			<p>
				<strong>Likely Usage:</strong>
				One useful application for the <code>retarget()</code> method is the case where it is desireable
				to define a sequence before the object to which it will apply yet exists.
				This may be handy for dynamically generated page content. You can create a sequence with a dummy target
				object and then later retarget it when the HTML element or other object needed exists.
				(Just make sure, of course, that you don't try to run a transformation that doesn't have a valid
				target object; that could obviously result in run-time errors.)
			</p>
		</div>

		<div class="TutorialStep"> <!-- Cloning -->
			<h4>Cloning</h4>
			<p>
				A single sequence can be defined and then cloned so that the same transformations are applied to other target objects.
			</p>
			<p>
				In the below example, when the "Go" button is first clicked, a sequence is begun that moves the two white dots.
				One second later, the sequence is cloned into a new sequence targeting the two yellow boxes.
				On subsequent clicks of the "Go" button, both sequences are run side-by-side from the beginning
				(Until the "Reset" button is clicked, at which point the demonstration is set back to its initial state).
				This also demonstrates that a sequence can even be cloned while it is already running and the new (cloned) sequence can
				(if desired) automatically jump to the same position and start running also.
			</p>
			<div class="TutorialSingleDemoContainer">
				<iframe class="TutorialDemoFrame TallDemoFrame" src="TutorialExamples/Page08Example02.html"></iframe>
				<div class="TutorialDemoFrameCaption"><a href="CodeViewer.html?url=TutorialExamples/Page08Example02.html" target="_blank">See Full Source Code</a></div>
			</div>
			<p>
				The important part of the code is listed below.
			</p>
			<p>
				<pre><code>const GoButton = document.getElementById("GoButton"),
  ResetButton = document.getElementById("ResetButton");

function doCloning(sequence)
{
  let newSequence = sequence.clone(
    function (originalTargetObject)
    {
      return document.getElementById(originalTargetObject.id.replace("Dot", "Box"));
    },
    true);
  return newSequence;
}

let originalSequence = new Concert.Sequence(),
  clonedSequence = null;
originalSequence.setDefaults(
  {
    applicator: Concert.Applicators.Style,
    easing: Concert.EasingFunctions.QuadIn,
    unit: "px"
  });
originalSequence.addTransformations(
  [
    {
      target: document.getElementById("Dot0"),
      feature: "top",
      keyframes: { times: [0, 2000], values: [0, 230] }
    },
    {
      target: document.getElementById("Dot1"),
      feature: "top",
      keyframes: { times: [0, 2000], values: [230, 0] }
    }
  ]);

GoButton.onclick =
  function ()
  {
    if (clonedSequence instanceof Concert.Sequence)
      clonedSequence.begin();
    else
    {
      GoButton.disabled = true;
      window.setTimeout(
        function()
        {
          clonedSequence = doCloning(originalSequence);
          GoButton.disabled = false;
        }, 1000);
    }
    originalSequence.begin();
  };</code></pre>
			</p>
			<p>
				The above code creates a single <code>Concert.Sequence</code> object to start with,
				and adds two transformations to it: one moving Dot0 downward and one moving Dot1 upward.
			</p>
			<p>
				When the user clicks the "Go" button, that sequence is begun. But a timeout is also set up to
				fire 1 second later (while the animation is underway). When it does, it calls the
				<code>doCloning()</code> function.
			</p>
			<p>
				The <code>doCloning()</code> function takes the original sequence and clones it into a new sequence.
				It calls the sequence's <code>clone()</code> method, which takes as its first argument a function used
				to figure out what the target objects should be for each transformation in the new sequence.
				In this case, it finds a corresponding element with the same <code>id</code> value except with the string "Box" replacing "Dot".
				(So for all transformations in the original sequence targeting the element "Dot0", there will be corresponding
				transformations in the cloned sequence targeting the element "Box0", and so on.)
			</p>
			<p>
				The second (and optional) argument to a sequence's <code>clone()</code> method tells it
				whether to match the original sequence's <em>running</em> status.
				Here it is set to <code>true</code>, at a time when the original sequence is indeed running,
				so the new clone sequence will, upon creation, immediately jump to the same position
				as the one it is cloned from and begin running as well.
			</p>
			<p>
				There is also allowed a third (optional) argument to this method, only meaningful when the second argument is <code>false</code>:
				another Boolean value, indicating whether the new sequence should do an initial seek to the same position as the original sequence
				but <em>without</em> necessarily starting to run.
			</p>
		</div>

		<p class="PreviousTutorialLink">
			<a href="tutorial07.html">Previous: 07 - Repeating</a>
		</p>
		<p class="NextTutorialLink">
			<a href="tutorial09.html">Next: 09 - Indexing, Value Generator Functions</a>
		</p>
	</div>
</template:data>


<!-- ================================================================= -->
<!-- TUTORIAL 09: Indexing, Value Generator Functions -->
<template:data target="tutorial09.html" section="MainContent">
	<div>
		<div class="TutorialNavigation">
			<ol>
				<li><a href="tutorial01.html">Sequences and Transformations</a></li>
				<li><a href="tutorial02.html">Easing Functions</a></li>
				<li><a href="tutorial03.html">Calculators</a></li>
				<li><a href="tutorial04.html">Applicators</a></li>
				<li><a href="tutorial05.html">Setting Defaults</a></li>
				<li><a href="tutorial06.html">Starting, Stopping, Seeking, and Synchronizing</a></li>
				<li><a href="tutorial07.html">Repeating</a></li>
				<li><a href="tutorial08.html">Cloning and Retargeting</a></li>
				<li><strong>Indexing, Value Generator Functions</strong></li>
				</ol>
		</div>
		<div class="TutorialIntroSection">
			Tutorial page #09
		</div>
		<div class="TutorialStep">
			Here is where the instructions go.
		</div>
	</div>
</template:data>
